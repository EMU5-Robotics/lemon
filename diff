diff --git a/src/main.rs b/src/main.rs
index c3ddf94..b697ec9 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,6 +1,9 @@
 use protocol::device::ControllerButtons;
 
 use crate::{
+	logging::*,
+	odom::*,
+	pid::*,
 	replay::Player,
 	state::{GlobalState, InputChanges, InputState, RerunLogger},
 	units::*,
@@ -46,7 +49,8 @@ fn main() -> anyhow::Result<()> {
 	let flipper = state.take_motor(14, true);
 
 	// let target = meter_per_second!(0.1);
-	//let _turning_pid = AnglePid::new(0.3, 0.3, 0.3, radian!(1.0));
+	let mut tpid = AnglePid::new(5.45, 0.0, 0.0, degree!(90.0));
+	let logger = state.network.rerun_logger();
 
 	// let logger = state.network.rerun_logger();
 	loop {
@@ -68,12 +72,36 @@ fn main() -> anyhow::Result<()> {
 
 			odom.update(&mut drive);
 
-			let axes = input.controller.axes_as_f32();
-			let d_power = axes[1];
-			let t_power = axes[2];
+			//let axes = input.controller.axes_as_f32();
+			//let d_power = axes[1];
+			//let t_power = axes[2];
 
 			flipper.voltage(flipper_mv(input.controller));
-			drive.drive(d_power, t_power);
+			//drive.drive(d_power, t_power);
+			let angle = odom.angle();
+			let angular_vel = tpid.step(logger.clone(), angle);
+
+			let side_spacing: Length = meter!(0.14); // 28cm between sides?
+			let mut side_vel = angular_vel * side_spacing;
+
+			// scale velocity to stay within velocity limits
+			let max_vel: Velocity = meter_per_second!(1.0);
+			let scale = max_vel / side_vel.abs();
+			if scale.value < 1.0 {
+				side_vel = side_vel * scale;
+			}
+
+			// set PID targets
+			drive.set_velocity(-side_vel, side_vel);
+			logger.clone().with(|rec, _| {
+				timeseries(rec, "odom/target_angle", 90.0);
+				//timeseries(rec, "odom/target_vel", side_vel.value);
+				//timeseries(rec, "odom/target_angular_vel", angular_vel.value);
+			});
+			//left_vel_pid.change_target(-side_vel);
+			//right_vel_pid.change_target(side_vel);
+
+			//let cur_side_vel = odom.side_vel();
 
 			// drive.set_velocity(target, target);
 		}
@@ -85,7 +113,7 @@ fn main() -> anyhow::Result<()> {
 }
 
 fn setup_field_rerun(logger: RerunLogger) {
-	logger.with(|rec, _| {
+	/*logger.with(|rec, _| {
 		rec.log_timeless("/", &rerun::ViewCoordinates::RIGHT_HAND_Z_UP)
 			.unwrap();
 		rec.log_timeless(
@@ -109,7 +137,7 @@ fn setup_field_rerun(logger: RerunLogger) {
 
 		rec.log_timeless("robot", &robot).unwrap();
 		rec.flush_blocking();
-	});
+	});*/
 }
 
 fn create_odometry(logger: RerunLogger) -> anyhow::Result<odom::DriveImuOdom> {
diff --git a/src/odom.rs b/src/odom.rs
index 9f6743c..a400394 100644
--- a/src/odom.rs
+++ b/src/odom.rs
@@ -120,19 +120,19 @@ impl DriveImuOdom {
 
 		self.vel = (dx / time, dy / time);
 
-		if self.log_update.elapsed() > Duration::from_millis(32) {
+		if self.log_update.elapsed() > Duration::from_millis(3) {
 			self.logger.with(|rerun, start| {
 				rerun.set_time_seconds("odom", start.elapsed().as_secs_f64());
 
 				// timeseries_colour(rerun, "odom/pos/x", self.pos.0.value, [127, 0, 127]);
 				// timeseries_colour(rerun, "odom/pos/y", self.pos.1.value, [0, 127, 127]);
-				// timeseries_colour(
-				// 	rerun,
-				// 	"odom/angle",
-				// 	self.angle.value.to_degrees(),
-				// 	[127, 127, 0],
-				// );
-				set_robot_offset(rerun, self.pos, self.angle);
+				timeseries_colour(
+					rerun,
+					"odom/angle",
+					self.angle.value.to_degrees(),
+					[127, 127, 0],
+				);
+				//set_robot_offset(rerun, self.pos, self.angle);
 			});
 			self.log_update = Instant::now();
 		}
diff --git a/src/path.rs b/src/path.rs
index f32b36d..b9539ee 100644
--- a/src/path.rs
+++ b/src/path.rs
@@ -132,30 +132,31 @@ impl PathSegment {
 		match self {
 			Self::TurnTo { target: _, offset } => {
 				// todo: change output from ratio to side velocity or angular velocity
-				let angular_velocity = turn_pid.step(odom.angle() + *offset);
+				todo!();
+				//let angular_velocity = turn_pid.step(odom.angle() + *offset);
 
 				let side_spacing: Length = meter!(0.1); // 20cm between sides?
-				let mut side_vel = angular_velocity * side_spacing;
+				                        /*let mut side_vel = angular_velocity * side_spacing;
 
-				// scale velocity to stay within velocity limits
-				let max_vel: Velocity = meter_per_second!(1.0);
-				let scale = max_vel / side_vel;
-				if scale.value < 1.0 {
-					side_vel = side_vel * scale;
-				}
+										// scale velocity to stay within velocity limits
+										let max_vel: Velocity = meter_per_second!(1.0);
+										let scale = max_vel / side_vel;
+										if scale.value < 1.0 {
+											side_vel = side_vel * scale;
+										}
 
-				// set PID targets
-				left_vel_pid.change_target(-side_vel);
-				right_vel_pid.change_target(side_vel);
+										// set PID targets
+										left_vel_pid.change_target(-side_vel);
+										right_vel_pid.change_target(side_vel);
 
-				let cur_side_vel = odom.side_vel();
+										let cur_side_vel = odom.side_vel();
 
-				// todo: double check coordinate system
-				// calculate motor powers with PIDs
-				let left_power = left_vel_pid.step(cur_side_vel.0);
-				let right_power = right_vel_pid.step(cur_side_vel.1);
+										// todo: double check coordinate system
+										// calculate motor powers with PIDs
+										//let left_power = left_vel_pid.step(cur_side_vel.0);
+										//let right_power = right_vel_pid.step(cur_side_vel.1);
 
-				Some((left_power, right_power))
+										Some((left_power, right_power))*/
 			}
 			Self::Path {
 				points,
@@ -207,10 +208,11 @@ impl PathSegment {
 				let side_vel = odom.side_vel();
 
 				// calculate motor powers with PIDs
-				let left_power = left_vel_pid.step(side_vel.0);
-				let right_power = right_vel_pid.step(side_vel.1);
+				//let left_power = left_vel_pid.step(side_vel.0);
+				//let right_power = right_vel_pid.step(side_vel.1);
+				todo!();
 
-				Some((left_power, right_power))
+				//Some((left_power, right_power))
 			}
 		}
 	}
diff --git a/src/pid.rs b/src/pid.rs
index 209cffb..994d26f 100644
--- a/src/pid.rs
+++ b/src/pid.rs
@@ -1,3 +1,4 @@
+use crate::{logging::*, RerunLogger};
 use std::{
 	marker::PhantomData,
 	time::{Duration, Instant},
@@ -31,18 +32,27 @@ impl<T: Dimension + ?Sized, O: Dimension + ?Sized> Pid<T, O> {
 		}
 	}
 
-	pub fn step(&mut self, pv: Quantity<T, SI<f64>, f64>) -> Quantity<O, SI<f64>, f64> {
+	pub fn step(
+		&mut self,
+		logger: RerunLogger,
+		pv: Quantity<T, SI<f64>, f64>,
+	) -> Quantity<O, SI<f64>, f64> {
 		let pv = pv.value;
 
 		let dt = self.time.elapsed().as_secs_f64();
-		if dt > Duration::from_micros(6000).as_secs_f64() {
+		/*if dt > Duration::from_micros(6000).as_secs_f64() {
 			return self.last_output;
-		}
+		}*/
 		self.time = Instant::now();
 
 		let err = self.target.value - pv;
 
+		logger.clone().with(|rec, _| {
+			timeseries(rec, "odom/error", err.value().to_degrees());
+		});
+
 		let prop_term = self.kp * err;
+		//println!("{prop_term}");
 
 		// modifications to integration are done to prevent integral windup
 		// see https://en.wikipedia.org/wiki/Integral_windup
